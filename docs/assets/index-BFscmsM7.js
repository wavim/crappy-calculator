(function(){const r=document.createElement("link").relList;if(r&&r.supports&&r.supports("modulepreload"))return;for(const h of document.querySelectorAll('link[rel="modulepreload"]'))O(h);new MutationObserver(h=>{for(const l of h)if(l.type==="childList")for(const g of l.addedNodes)g.tagName==="LINK"&&g.rel==="modulepreload"&&O(g)}).observe(document,{childList:!0,subtree:!0});function y(h){const l={};return h.integrity&&(l.integrity=h.integrity),h.referrerPolicy&&(l.referrerPolicy=h.referrerPolicy),h.crossOrigin==="use-credentials"?l.credentials="include":h.crossOrigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function O(h){if(h.ep)return;h.ep=!0;const l=y(h);fetch(h.href,l)}})();var n;(t=>{(r=>{r[r.Prefix=0]="Prefix",r[r.Postfix=1]="Postfix",r[r.Function=2]="Function"})(t.UnaryOpTypes||(t.UnaryOpTypes={})),(r=>{r[r.Bracket=0]="Bracket",r[r.Numeral=1]="Numeral",r[r.UnaryOp=2]="UnaryOp",r[r.BinaryOp=3]="BinaryOp"})(t.TokenTypes||(t.TokenTypes={})),(r=>{r[r.Root=0]="Root",r[r.Numeral=1]="Numeral",r[r.UnaryOp=2]="UnaryOp",r[r.BinaryOp=3]="BinaryOp"})(t.TreeTypes||(t.TreeTypes={}))})(n||(n={}));var p;(t=>{t.constantRegistry=new Map,t.constantSymbolRegistry=new Map,t.unaryOpRegistry=new Map,t.unaryOpSymbolRegistry=new Map,t.binaryOpRegistry=new Map,t.binaryOpSymbolRegistry=new Map;function r(o){return t.constantRegistry.has(o)}t.existConstant=r;function y(o){return t.constantSymbolRegistry.has(o)}t.existConstantWithSymbol=y;function O(o){return t.unaryOpRegistry.has(o)}t.existUnaryOp=O;function h(o){return t.unaryOpSymbolRegistry.has(o)}t.existUnaryOpWithSymbol=h;function l(o){return t.binaryOpRegistry.has(o)}t.existBinaryOp=l;function g(o){return t.binaryOpSymbolRegistry.has(o)}t.existBinaryOpWithSymbol=g;function a(o,b){if(r(o))throw new Error(`Constant with id ${o} already exists.`);if(y(b.symbol))throw new Error(`Constant with symbol ${b.symbol} already exists.`);t.constantRegistry.set(o,b),t.constantSymbolRegistry.set(b.symbol,b)}t.registerConstant=a;function d(o,b){if(O(o))throw new Error(`Unary operator with id ${o} already exists.`);if(h(b.symbol))throw new Error(`Unary operator with symbol ${b.symbol} already exists.`);t.unaryOpRegistry.set(o,b),t.unaryOpSymbolRegistry.set(b.symbol,b)}t.registerUnaryOp=d;function w(o,b){if(l(o))throw new Error(`Binary operator with id ${o} already exists.`);if(g(b.symbol))throw new Error(`Binary operator with symbol ${b.symbol} already exists.`);t.binaryOpRegistry.set(o,b),t.binaryOpSymbolRegistry.set(b.symbol,b)}t.registerBinaryOp=w;function E(){return[...t.constantSymbolRegistry.keys()]}t.getConstantSymbols=E;function u(){return[...t.unaryOpSymbolRegistry.keys()]}t.getUnaryOpSymbols=u;function m(){return[...t.binaryOpSymbolRegistry.keys()]}t.getBinaryOpSymbols=m;function f(o){if(!r(o))throw new Error(`Constant with id ${o} is not registered.`);return t.constantRegistry.get(o)}t.getConstant=f;function c(o){if(!y(o))throw new Error(`Constant with symbol ${o} is not registered.`);return t.constantSymbolRegistry.get(o)}t.getConstantWithSymbol=c;function e(o){if(!O(o))throw new Error(`Unary operator with id ${o} is not registered.`);return t.unaryOpRegistry.get(o)}t.getUnaryOp=e;function i(o){if(!h(o))throw new Error(`Unary operator with symbol ${o} is not registered.`);return t.unaryOpSymbolRegistry.get(o)}t.getUnaryOpWithSymbol=i;function s(o){if(!l(o))throw new Error(`Binary operator with id ${o} is not registered.`);return t.binaryOpRegistry.get(o)}t.getBinaryOp=s;function T(o){if(!g(o))throw new Error(`Binary operator with symbol ${o} is not registered.`);return t.binaryOpSymbolRegistry.get(o)}t.getBinaryOpWithSymbol=T})(p||(p={}));var U;(t=>{function y(a){if(a>=0&&a<100&&Number.isInteger(a)){let d=1;for(let w=2;w<a+1;w++)d*=w;return d}return h(a+1)}t.factorial=y;function O(a){return y(a-1)}t.gamma=O;function h(a){const w=[.9999999999998099,676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,15056327351493116e-23];if(a<.5)return Math.PI/(Math.sin(Math.PI*a)*h(1-a));a--;let E=w[0];for(let m=1;m<9;m++)E+=w[m]/(a+m);const u=a+7+.5;return Math.sqrt(2*Math.PI)*Math.pow(u,a+.5)*Math.exp(-u)*E}function l(a,d){return y(a)/y(a-d)}t.permutation=l;function g(a,d){return l(a,d)/y(d)}t.combination=g})(U||(U={}));function P(){p.registerConstant("e",{symbol:"E",value:Math.E}),p.registerConstant("pi",{symbol:"PI",value:Math.PI}),p.registerUnaryOp("pos",{symbol:"+",type:n.UnaryOpTypes.Prefix,callback:r=>r}),p.registerUnaryOp("neg",{symbol:"-",type:n.UnaryOpTypes.Prefix,callback:r=>-r}),p.registerUnaryOp("factorial",{symbol:"!",type:n.UnaryOpTypes.Postfix,callback:U.factorial}),p.registerUnaryOp("abs",{symbol:"abs",type:n.UnaryOpTypes.Function,callback:Math.abs}),p.registerUnaryOp("sqrt",{symbol:"sqrt",type:n.UnaryOpTypes.Function,callback:Math.sqrt}),p.registerUnaryOp("exp",{symbol:"exp",type:n.UnaryOpTypes.Function,callback:Math.exp}),p.registerUnaryOp("log",{symbol:"Ln",type:n.UnaryOpTypes.Function,callback:Math.log}),p.registerUnaryOp("log10",{symbol:"log",type:n.UnaryOpTypes.Function,callback:Math.log10}),p.registerUnaryOp("sin",{symbol:"sin",type:n.UnaryOpTypes.Function,callback:Math.sin}),p.registerUnaryOp("cos",{symbol:"cos",type:n.UnaryOpTypes.Function,callback:Math.cos}),p.registerUnaryOp("tan",{symbol:"tan",type:n.UnaryOpTypes.Function,callback:Math.tan}),p.registerUnaryOp("gamma",{symbol:"Gamma",type:n.UnaryOpTypes.Function,callback:U.gamma}),p.registerBinaryOp("add",{symbol:"+",callback:(r,y)=>r+y,precedence:0}),p.registerBinaryOp("sub",{symbol:"-",callback:(r,y)=>r-y,precedence:0}),p.registerBinaryOp("mul",{symbol:"*",callback:(r,y)=>r*y,precedence:1}),p.registerBinaryOp("div",{symbol:"/",callback:(r,y)=>r/y,precedence:1}),p.registerBinaryOp("pow",{symbol:"^",callback:(r,y)=>r**y,precedence:2}),p.registerBinaryOp("mod",{symbol:"%",callback:(r,y)=>r%y,precedence:2});const t=100;p.registerBinaryOp("min",{symbol:"min",callback:Math.min,precedence:t}),p.registerBinaryOp("max",{symbol:"max",callback:Math.max,precedence:t}),p.registerBinaryOp("permutation",{symbol:"P",callback:U.permutation,precedence:t}),p.registerBinaryOp("combination",{symbol:"C",callback:U.combination,precedence:t})}var B;(t=>{function r(u){const m=u.length,f=[];for(;u.length;){const c=m-u.length,e=g(u,c,f);u=u.slice(e.length)}return f}t.tokenize=r;class y{constructor(m,f,c){this.type=m,this.symbol=f,this.meta=c}toString(){return`Token[${this.meta.from}-${this.meta.to}]<${n.TokenTypes[this.type]}> ${this.symbol}`}}t.Token=y,P();const O=u=>u.replaceAll(/[.*+?^${}()|[\]\\]/g,"\\$&"),h=Object.keys(n.TokenTypes).length/2,l={[n.TokenTypes.Bracket]:/[()]/,[n.TokenTypes.Numeral]:new RegExp(`(?:${p.getConstantSymbols().sort((u,m)=>m.length-u.length).map(O).join(")|(?:")})|(?:\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)`),[n.TokenTypes.UnaryOp]:new RegExp(`(?:${p.getUnaryOpSymbols().sort((u,m)=>m.length-u.length).map(O).join(")|(?:")})`),[n.TokenTypes.BinaryOp]:new RegExp(`(?:${p.getBinaryOpSymbols().sort((u,m)=>m.length-u.length).map(O).join(")|(?:")})`)};function g(u,m,f){let c;for(let e=0;e<h;e++){const i=new RegExp(`^\\s*(?:${l[e].source})\\s*`);if(c=u.match(i)?.[0],c===void 0)continue;let s=c.trimStart();const T=m+c.length-s.length;s=s.trimEnd();const o=T+s.length-1,b={from:T,to:o},x=f.at(-1);switch(e){case n.TokenTypes.Bracket:{if(a(f,s,b,x))break;continue}case n.TokenTypes.Numeral:{if(d(f,s,b,x))break;continue}case n.TokenTypes.UnaryOp:{if(w(f,s,b,x))break;continue}case n.TokenTypes.BinaryOp:{if(E(f,s,b))break;continue}}break}if(!c)throw new SyntaxError(`Unknown symbol at position ${m}.`);return c}function a(u,m,f,c){const e=c?.symbol===")"||c?.type===n.TokenTypes.Numeral||c?.type===n.TokenTypes.UnaryOp&&p.getUnaryOpWithSymbol(c.symbol).type===n.UnaryOpTypes.Postfix;if(m==="("&&e&&p.existBinaryOp("mul")){const s=new y(n.TokenTypes.BinaryOp,p.getBinaryOp("mul").symbol,f);u.push(s)}const i=new y(n.TokenTypes.Bracket,m,f);return u.push(i)}function d(u,m,f,c){const e=c?.symbol===")"||c?.type===n.TokenTypes.Numeral||c?.type===n.TokenTypes.UnaryOp&&p.getUnaryOpWithSymbol(c.symbol).type===n.UnaryOpTypes.Postfix;if(p.existConstantWithSymbol(m)&&e&&p.existBinaryOp("mul")){const s=new y(n.TokenTypes.BinaryOp,p.getBinaryOp("mul").symbol,f);u.push(s)}const i=new y(n.TokenTypes.Numeral,m,f);return u.push(i)}function w(u,m,f,c){const e=c?.symbol===")"||c?.type===n.TokenTypes.Numeral||c?.type===n.TokenTypes.UnaryOp&&p.getUnaryOpWithSymbol(c.symbol).type===n.UnaryOpTypes.Postfix;switch(p.getUnaryOpWithSymbol(m).type){case n.UnaryOpTypes.Prefix:{if(e)return!1;break}case n.UnaryOpTypes.Postfix:{if(!e)return!1;break}case n.UnaryOpTypes.Function:{if(!e||!p.existBinaryOp("mul"))break;const s=new y(n.TokenTypes.BinaryOp,p.getBinaryOp("mul").symbol,f);u.push(s);break}}const i=new y(n.TokenTypes.UnaryOp,m,f);return u.push(i)}function E(u,m,f,c){const e=new y(n.TokenTypes.BinaryOp,m,f);return u.push(e)}})(B||(B={}));var $;(t=>{function r(c){const e=new g,i={index:0,position:()=>{const s=i.tokens[i.index];return`${s.meta.from} - ${s.meta.to}`},tokens:c,pointer:e};for(;i.index<c.length;){const s=c[i.index];switch(s.type){case n.TokenTypes.Bracket:{E(s,i);break}case n.TokenTypes.Numeral:{u(s,i);break}case n.TokenTypes.UnaryOp:{m(s,i);break}case n.TokenTypes.BinaryOp:{f(s,i);break}}i.index++}return e}t.parse=r;class y{constructor(e,i){this.type=e,this.precedence=i}clone(){const e=Object.create(Object.getPrototypeOf(this));return Object.defineProperties(e,Object.getOwnPropertyDescriptors(this)),e}}t.Tree=y;const O=-1,h=Number.MAX_SAFE_INTEGER+1,l=Number.MAX_SAFE_INTEGER;class g extends y{$content;set content(e){this.$content=e,e.parent=this}get content(){return this.$content}constructor(){super(n.TreeTypes.Root,O)}toString(){return`${this.content?this.content.toString():"<Empty>"}`}}t.RootTree=g;class a extends y{constructor(e,i){super(n.TreeTypes.Numeral,h),this.parent=e,this.numeral=i}toString(e=1){return`Tree<Numeral>${`
`+"  ┃  ".repeat(e)}${this.numeral}`}}t.NumeralTree=a;class d extends y{constructor(e,i){super(n.TreeTypes.UnaryOp,l),this.parent=e,this.operatorToken=i,this.operator=p.getUnaryOpWithSymbol(i.symbol),this.meta=i.meta}$argument;set argument(e){this.$argument=e,e.parent=this}get argument(){return this.$argument}operator;meta;toString(e=1){const i=`
`+"  ┃  ".repeat(e);return`Tree<Unary>${i}Operator: ${this.operatorToken}${i}Argument: ${this.argument?this.argument.toString(e+1):"<Empty>"}`}}t.UnaryOpTree=d;class w extends y{constructor(e,i){const s=p.getBinaryOpWithSymbol(i.symbol);super(n.TreeTypes.BinaryOp,s.precedence),this.parent=e,this.operatorToken=i,this.operator=s,this.meta=i.meta}$left;$right;set left(e){this.$left=e,e.parent=this}get left(){return this.$left}set right(e){this.$right=e,e.parent=this}get right(){return this.$right}operator;meta;toString(e=1){const i=`
`+"  ┃  ".repeat(e);return`Tree<Binary>${i}Operator: ${this.operatorToken}${i}Left: ${this.left?this.left.toString(e+1):"<Empty>"}${i}Right: ${this.right?this.right.toString(e+1):"<Empty>"}`}}t.BinaryOpTree=w;function E(c,e){if(c.symbol===")")throw new SyntaxError(`Lone right bracket at ${e.position()}.`);if(e.pointer.type===n.TreeTypes.Numeral)throw new SyntaxError(`Missing operator before bracket at ${e.position()}.`);const i=e.index;let s=i,T=1;for(;s<e.tokens.length-1&&(s++,!(e.tokens[s].type===n.TokenTypes.Bracket&&(e.tokens[s].symbol==="("?T++:T--,T===0))););if(T!==0)throw new SyntaxError(`Unbalanced bracket at ${e.position()}.`);if(s===i+1)throw new SyntaxError(`Empty brackets at ${e.position()}.`);e.index=s;const o=r(e.tokens.slice(i+1,s));switch(o.content.precedence=h,e.pointer.type){case n.TreeTypes.Root:{const b=e.pointer;e.pointer=b.content=o.content;break}case n.TreeTypes.UnaryOp:{const b=e.pointer;e.pointer=b.argument=o.content;break}case n.TreeTypes.BinaryOp:{const b=e.pointer;e.pointer=b.right=o.content;break}}}function u(c,e){if(e.pointer.type===n.TreeTypes.Numeral)throw new SyntaxError(`Missing operator between numerals at ${e.position()}.`);const i=new a(e.pointer,c);switch(e.pointer.type){case n.TreeTypes.Root:{const s=e.pointer;e.pointer=s.content=i;break}case n.TreeTypes.UnaryOp:{const s=e.pointer;e.pointer=s.argument=i;break}case n.TreeTypes.BinaryOp:{const s=e.pointer;e.pointer=s.right=i;break}}}function m(c,e){for(;e.pointer.type!==n.TreeTypes.Root&&e.pointer.precedence>l;)e.pointer=e.pointer.parent;const s=p.getUnaryOpWithSymbol(c.symbol).type===n.UnaryOpTypes.Postfix;if(s&&!(e.pointer.type===n.TreeTypes.Root&&e.pointer.content||e.pointer.type===n.TreeTypes.UnaryOp&&e.pointer.argument||e.pointer.type===n.TreeTypes.BinaryOp&&e.pointer.right))throw new SyntaxError(`Missing entry before postfix unary operator at ${e.position()}.`);const T=new d(e.pointer,c);switch(e.pointer.type){case n.TreeTypes.Root:{const o=e.pointer;s&&(T.argument=o.content.clone()),e.pointer=o.content=T;break}case n.TreeTypes.UnaryOp:{const o=e.pointer;s&&(T.argument=o.argument.clone()),e.pointer=o.argument=T;break}case n.TreeTypes.BinaryOp:{const o=e.pointer;s&&(T.argument=o.right.clone()),e.pointer=o.right=T;break}}}function f(c,e){if(e.pointer.type===n.TreeTypes.Root)throw new SyntaxError(`Missing entry before binary operator at ${e.position()}.`);const i=p.getBinaryOpWithSymbol(c.symbol);for(;e.pointer.precedence>=i.precedence;)e.pointer=e.pointer.parent;const s=new w(e.pointer,c);switch(e.pointer.type){case n.TreeTypes.Root:{const T=e.pointer;s.left=T.content.clone(),e.pointer=T.content=s;break}case n.TreeTypes.UnaryOp:{const T=e.pointer;s.left=T.clone(),e.pointer=T.argument=s;break}case n.TreeTypes.BinaryOp:{const T=e.pointer;s.left=T.right.clone(),e.pointer=T.right=s;break}}}})($||($={}));var C;(t=>{function r(a){switch(a.type){case n.TreeTypes.Root:return y(a);case n.TreeTypes.Numeral:return O(a);case n.TreeTypes.UnaryOp:return h(a);case n.TreeTypes.BinaryOp:return l(a)}}t.evaluate=r;function y(a){if(!a.content)throw new SyntaxError("Evaluating empty tree.");return r(a.content)}function O(a){const d=a.numeral.symbol;return p.existConstantWithSymbol(d)?p.getConstantWithSymbol(d).value:Number(d)}function h(a){if(!a.argument)throw new SyntaxError(`Unary operator lacks argument at ${g(a.meta)}.`);const d=p.getUnaryOpWithSymbol(a.operator.symbol).callback;return d(r(a.argument))}function l(a){if(!a.left)throw new SyntaxError(`Binary operator lacks left operand at ${g(a.meta)}.`);if(!a.right)throw new SyntaxError(`Binary operator lacks right operand at ${g(a.meta)}.`);const d=p.getBinaryOpWithSymbol(a.operator.symbol).callback,w=r(a.left),E=r(a.right);return d(w,E)}const g=a=>`${a.from} - ${a.to}`})(C||(C={}));var N;(t=>{function r(O){const h=B.tokenize(O),l=$.parse(h),g=C.evaluate(l);return{tokens:h,tree:l,value:g}}t.calculate=r;function y(O){return r(O).value}t.value=y})(N||(N={}));const v=50,S=document.getElementById("input"),k=document.getElementById("result");M(S.getAttribute("placeholder"));S.oninput=()=>M(S.value);function M(t){console.clear(),k.classList.remove("error");let r;try{r=N.calculate(t.length===0?S.getAttribute("placeholder"):t)}catch(y){k.innerHTML="",k.classList.add("error");const O=document.createElement("p");O.textContent=`${y}`.replace(/.*Error: /,""),k.appendChild(O);return}console.log(`${r.tree}`),R(r.tokens,r.value)}function R(t,r){if(k.innerHTML="",(l=>{let g=0;for(const a of l)g+=a;return g})(t.map(l=>l.symbol.length))>v){const l=document.createElement("p");l.textContent="Expression",k.appendChild(l)}else for(const l of t){const g=document.createElement("p");g.textContent=l.symbol,g.className=n.TokenTypes[l.type],k.appendChild(g)}const O=document.createElement("p");O.textContent=" = ",k.appendChild(O);const h=document.createElement("p");h.textContent=`${r}`,k.appendChild(h)}
